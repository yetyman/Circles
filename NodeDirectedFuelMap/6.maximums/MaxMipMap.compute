#version 430
layout(local_size_x = 2, local_size_y = 2) in;//pixel size of local work group, for a binary tree this would be 2

layout(r16f, binding = 0, location = 0) uniform readonly image2D img_input;//single value image2d of floats
layout(location = 2) uniform unsigned int mip_level;

layout(rgba16f, binding = 1, location = 1) uniform image2D img_mipmaps;//same dimensions should hold all the maps, rgba to hold the positions and value from the img_input

void main() {
    // get index in global work group i.e x,y position
    ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);
    ivec2 input_image_size = imageSize(img_input);
    
    //imageStore(img_mipmaps, pixel_coords, vec4(1, float(pixel_coords.x)/float(input_image_size.x)*2, float(pixel_coords.y) / float(input_image_size.y), 1));//test call. setting the current pixel to blue

    //only process if its within the next mip's area(bounds check)
    if (   pixel_coords.y > input_image_size.y * pow(.5, mip_level)
        && pixel_coords.y <= input_image_size.y * pow(.5, (mip_level - 1))
        && pixel_coords.x < input_image_size.x * pow(.5, (mip_level )))
    {
        uint adjustedpixel_coord = uint(pixel_coords.y - input_image_size.y * pow(.5, mip_level));
        imageStore(img_mipmaps, pixel_coords, vec4(0, 1, 0, 1));

        //read image2d at pixel_coords? can i not just img_input[pixel_coords]? well syntax is syntax
        //(x,y,value)
        vec3 color00;
        vec3 color01;
        vec3 color10;
        vec3 color11;
        
        //use input image as source
        if (mip_level == 1) {
            ivec2 og_coord = ivec2(pixel_coords.x, adjustedpixel_coord) * 2;
            color00 = vec3(imageLoad(img_input, og_coord + ivec2(0, 0)).x, og_coord + vec2(0, 0));
            color01 = vec3(imageLoad(img_input, og_coord + ivec2(0, 1)).x, og_coord + vec2(0, 1));
            color10 = vec3(imageLoad(img_input, og_coord + ivec2(1, 0)).x, og_coord + vec2(1, 0));
            color11 = vec3(imageLoad(img_input, og_coord + ivec2(1, 1)).x, og_coord + vec2(1, 1));
        }
        //use img_mipmaps as source
        else {
            ivec2 prev_mip_coord = pixel_coords * 2;
            color00 = imageLoad(img_mipmaps, prev_mip_coord + ivec2(0, 0)).xyz;
            color01 = imageLoad(img_mipmaps, prev_mip_coord + ivec2(0, 1)).xyz;
            color10 = imageLoad(img_mipmaps, prev_mip_coord + ivec2(1, 0)).xyz;
            color11 = imageLoad(img_mipmaps, prev_mip_coord + ivec2(1, 1)).xyz;
        }

        //comparison algorithm - maximum
        vec3 finalist1;
        vec3 finalist2;
        if (color00.x > color01.x)
            finalist1 = color00;
        else finalist1 = color01;

        if (color10.x > color11.x)
            finalist2 = color10;
        else finalist2 = color11;

        if (finalist2.x > finalist1.x)
            finalist1 = finalist2;

        //set the mipmap coordinate here
        imageStore(img_mipmaps, pixel_coords, vec4(finalist1,1));
    }
}